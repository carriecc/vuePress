---
tag: 
  - 安全
---

# 跨站请求伪造（CSRF）防御

CSRF 是指一个恶意网站，邮件，博客，即时信息或者程序引起用户的浏览器在一个信任的网站执行一些非本意的操作，而在那个网站用户是处于已认证的状态。CSRF 攻击造成的后果视乎受害应用的能力。例如，这种攻击可以转账，修改密码，或者用受害人的账户买东西。实际上，CSRF 攻击被用于制造一个通过目标浏览器执行操作的系统，并且在未授权的交易提交以前，是不知道目标用户是谁的。

CSRF 引起的后果很大程度取决于受害者的权限。如果攻击一个普通用户，CSRF 攻击可以破解终端用户数据和相关功能。如果攻击的是一个管理员账户，CSRF 可以破解整个应用。社区网站（社交网络，邮件）或者关联了巨额账户的网站（银行，账单支付服务）更容易受到 CSRF 攻击。利用社交网络，攻击者可以把恶意 HTML 或者 JavaScript 嵌入到一封邮件或者网站里，这些恶意代码可以在用户知情或者不知情的情况下，直接或者通过利用一个 XSS 漏洞向“任务 URL”发起请求。

CSRF 并不需要 XSS 来生效。但是，任何 XSS 可以被利用来破解 token。这是因为 XSS payload 可以使用一个 XMLHttpRequest 来阅读任何页面，并从响应中获取生成的 token，并在伪造的请求中包含这个 token。XSS 不能越过质询-响应防御，比如验证码，重认证或者一次性密码。要确保没有 XSS 来让 CSRF 防御可以被绕过。

## 自动化 CSRF 防御的建议

1. 检查标准头部，确认请求是同源的。
2. 检查 CSRF token。

## 确保标准头部同源

1. 确定请求的来源
2. 确定请求的去向

这两步都要检查 HTTP 请求头的值。尽管在浏览器中用 JavaScript 来仿造一个头部很难，在一次 CSRF 攻击中在受害者的浏览器要完成这样的操作通常是不可能的，除非网站中有一个 XSS 漏洞被 CSRF 攻击。因此这个同源的检查就显得重要了，大部分的 HTTP 请求头都不能通过 JavaScript 来设置因为它们是在[禁止头部名单](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)上的。只有浏览器自己可以为这些头设置值，使得这些头部更可靠了，因为即使有个 XSS 漏洞也无法修改它们。

同源检查依赖于三个被保护的头：Origin, Referer 和 Host，光是靠这些 CSRF 防御就很强了。

### 确认来源

要确认来源，我们推荐检查这两个标准头，几乎所有请求都会包含它们：

- Origin 头
- Referer 头

#### 检查 Origin 头

如果有 Origin 头，请确认它的值匹配目标 origin。[Origin HTTP header](https://wiki.mozilla.org/Security/Origin) 标准是作为抵御 CSRF 和其他跨域攻击的一种方法的。跟 Referer 不同，Origin 头会在来自英国 HTTPS URL 的 HTTP 请求中出现。

这个防御在 [CSRF 的健壮防御](https://seclab.stanford.edu/websec/csrf/csrf.pdf)第五章中被特别推荐。这篇文章提出了 Origin 头的诞生以及它作为 CSRF 防御机制的作用。

有一些请求 Origin 头不会出现。

- [IE 11 在 CORS 请求中不会添加 Origin 头](http://stackoverflow.com/questions/20784209/internet-explorer-11-does-not-add-the-origin-header-on-a-cors-request)在信任的网站。Referer 会作为 UI 源的唯一标志。
- [后面跟着一个 302 重定向 跨域](http://stackoverflow.com/questions/22397072/are-there-any-browsers-that-set-the-origin-header-to-null-for-privacy-sensitiv)。重定向请求中不会包含 Origin，因为这被当做敏感信息，你不想要发到其他源。但尽管我们建议拒绝没有同时具有 Origin 和 Referer 头的请求，这种情况是 OK 的，因为 Origin 头不在的原因是它是一个跨域重定向。

#### 检查 Referer 头

如果没有 Origin 头，就检查 Referer 中的主机名是否与目标源匹配。检查 Referer 是嵌入式网络设备防御 CSRF 的一种常用的方法，因为它不需要任何单用户状态。当内存不足或者服务器端状态不存在，Referer 称为一个很好的 CSRF 防御方法。这种方法在非认证请求，比如在建立一个 session 状态前的请求（这个 session 状态需要跟踪一个同步的 token）很常用。

以上两种情况，仅仅确保了目标源检查。比如，如果你的网站是“site.com”，请确保"site,com.attacker.com"不会通过你的源检查（例如，/ 后面的路径也要检查，确保你匹配了完整的源）。

#### 如果 Origin 头和 Referer 头都没有出现

你可以接收也可以拒绝请求。**我们建议拒绝**。尤其是你正在使用一个随机的 CSRF token 作为你的二次检查。

### 确认去向

你可能认为确认目标源很容易，但事实并不是。首先想到的是简单的从请求的 URL 中获取目标源（比如，它的主机名和端口）。然而，服务器往往处于一个或多个代理后面，接收到的 URL 已经跟原来的不一样了。如果服务器直接被用户接入，那么可以使用 URL。

#### 在代理后面查明目标源

如果你处于一个代理后面，有几种选择：

1. 配置你的应用来知道它的目标源
2. 使用 Host header 值
3. 使用 X-Forwarded-Host header 值

因为是你的应用，因此你可以知道它的目标源以及在一些服务器配置入口设置那些值。这会是最保险的方法。但是，如果你的服务器部署在不同的地方，这样做可能很难维护，比如 dev，test，QA，production，还有可能的多个生产实例。为这些环境配置正确的值很难，但是如果可以做到是最好的。

如果你希望应用自己计算出来，这样就不需要为不同的部署实例进行不同配置，我们推荐使用 Host 族头部。Host 头的目的是在请求中包含目标源。但是，如果你的应用在一个代理后面，Host 头很可能被代理修改为代理后面的 URL 目标源，跟原始 URL 已经不一样了。这个被修改的 Host 头跟原始的 Origin 或者 Referer 不匹配。

然而，还有另一个 header 叫 X-Forwarded-Host，目的是包含代理接收到的源 Host 头。大多数代理都会在 X-Forwarded-Host 头中传入原始的 Host 头。因此这个值就基本会是你用来与 Origin 或者 Referer 中的来源比较的源值了。