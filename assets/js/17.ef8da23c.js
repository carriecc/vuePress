(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{292:function(t,e,a){"use strict";a.r(e);var s=a(3),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"正则表达式-向前查找和向后查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式-向前查找和向后查找"}},[t._v("#")]),t._v(" 正则表达式 - 向前查找和向后查找")]),t._v(" "),a("p",[t._v("有时候我们需要匹配一个跟在别的样式前面的样式。比如，需要拿到价格 1 turkey costs 30€。需要拿到后面跟了 € 的数字。")]),t._v(" "),a("h2",{attrs:{id:"向前查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向前查找"}},[t._v("#")]),t._v(" 向前查找")]),t._v(" "),a("p",[a("code",[t._v("x(?=y)")]),t._v("表示只有当 y 跟在后面才匹配 x。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let str = "1 turkey costs 30€";\n\nalert( str.match(/\\d+(?=€)/) ); // 30 (correctly skipped the sole number 1)\n')])])]),a("p",[t._v("或者，如果我们要找的是数量，就可以用负的向前查找，"),a("code",[t._v("x(?!y)")]),t._v("表示只有当 y 没有跟在后面才匹配 x。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let str = "2 turkeys cost 60€";\n\nalert( str.match(/\\d+(?!€)/) ); // 2 (correctly skipped the price)\n')])])]),a("h2",{attrs:{id:"向后查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向后查找"}},[t._v("#")]),t._v(" 向后查找")]),t._v(" "),a("ul",[a("li",[t._v("正的向后查找："),a("code",[t._v("(?<=y)x")]),t._v("，表示只有当 x 跟在 y 后面才匹配。")]),t._v(" "),a("li",[t._v("负的向后查找："),a("code",[t._v("(?<!y)x")]),t._v("，表示只有当前面没有 y 的时候才匹配 x。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let str = "1 turkey costs $30";\n\nalert( str.match(/(?<=\\$)\\d+/) ); // 30 (correctly skipped the sole number 1)\n')])])]),a("h2",{attrs:{id:"捕获组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获组"}},[t._v("#")]),t._v(" 捕获组")]),t._v(" "),a("p",[t._v("通常来讲，向前查找和向后查找的括号内容都不会称为匹配结果的一部分。但如果我们想要捕获，也是可以的。只需要将它放在另一个括号里。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let str = "1 turkey costs 30€";\nlet reg = /\\d+(?=(€|kr))/;\n\nalert( str.match(reg) ); // 30, €\n')])])]),a("p",[t._v("通常来说括号是从左到右编号的，但向后查找是个例外，总是在主样式以后捕获，因此"),a("code",[t._v("\\d+")]),t._v("的匹配先出现，然后才是"),a("code",[t._v("(\\$|€)")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("lookaround 也可以手动完成，也就是通过循环通过上下文匹配和过滤所有文本。比如"),a("code",[t._v("str.matchAll")]),t._v("和"),a("code",[t._v("reg.exec")]),t._v("会返回"),a("code",[t._v(".index")]),t._v("属性，因此可以知道文本的位置。但通过正则表达式来做更好")])])}),[],!1,null,null,null);e.default=r.exports}}]);